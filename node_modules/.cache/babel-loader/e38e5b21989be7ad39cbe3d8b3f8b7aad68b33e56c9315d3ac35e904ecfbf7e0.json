{"ast":null,"code":"// Common English stopwords\nconst STOPWORDS = new Set(['a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on', 'that', 'the', 'to', 'was', 'will', 'with', 'but', 'or', 'not', 'this', 'they', 'have', 'had', 'what', 'said', 'each', 'which', 'do', 'how', 'their', 'if', 'up', 'out', 'many', 'then', 'them', 'can', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'will']);\n\n/**\r\n * Preprocess text: lowercase, remove punctuation, filter stopwords\r\n */\nexport const preprocessText = text => {\n  if (!text) return [];\n  return text.toLowerCase().replace(/[^\\w\\s]/g, ' ') // Remove punctuation\n  .split(/\\s+/).filter(word => word.length > 2 && !STOPWORDS.has(word));\n};\n\n/**\r\n * Calculate keyword matching score\r\n */\nexport const calculateKeywordScore = (prompt, text) => {\n  const promptWords = preprocessText(prompt);\n  const textWords = preprocessText(text);\n  if (promptWords.length === 0) return 0;\n  const matches = promptWords.filter(word => textWords.includes(word));\n  return matches.length / promptWords.length; // Normalized score\n};\n\n/**\r\n * Calculate Term Frequency (TF)\r\n */\nconst calculateTF = words => {\n  const tf = {};\n  const totalWords = words.length;\n  words.forEach(word => {\n    tf[word] = (tf[word] || 0) + 1;\n  });\n\n  // Normalize by total words\n  Object.keys(tf).forEach(word => {\n    tf[word] = tf[word] / totalWords;\n  });\n  return tf;\n};\n\n/**\r\n * Calculate Inverse Document Frequency (IDF)\r\n */\nconst calculateIDF = documents => {\n  const idf = {};\n  const totalDocs = documents.length;\n\n  // Get all unique words\n  const allWords = new Set();\n  documents.forEach(doc => {\n    doc.forEach(word => allWords.add(word));\n  });\n\n  // Calculate IDF for each word\n  allWords.forEach(word => {\n    const docsWithWord = documents.filter(doc => doc.includes(word)).length;\n    idf[word] = Math.log(totalDocs / (docsWithWord + 1)); // +1 to avoid division by zero\n  });\n  return idf;\n};\n\n/**\r\n * Calculate TF-IDF vectors\r\n */\nconst calculateTFIDF = documents => {\n  const tfidfVectors = [];\n  const idf = calculateIDF(documents);\n  documents.forEach(doc => {\n    const tf = calculateTF(doc);\n    const tfidf = {};\n    Object.keys(tf).forEach(word => {\n      tfidf[word] = tf[word] * idf[word];\n    });\n    tfidfVectors.push(tfidf);\n  });\n  return tfidfVectors;\n};\n\n/**\r\n * Calculate cosine similarity between two TF-IDF vectors\r\n */\nconst cosineSimilarity = (vec1, vec2) => {\n  const words1 = Object.keys(vec1);\n  const words2 = Object.keys(vec2);\n  const allWords = new Set([...words1, ...words2]);\n  let dotProduct = 0;\n  let norm1 = 0;\n  let norm2 = 0;\n  allWords.forEach(word => {\n    const val1 = vec1[word] || 0;\n    const val2 = vec2[word] || 0;\n    dotProduct += val1 * val2;\n    norm1 += val1 * val1;\n    norm2 += val2 * val2;\n  });\n  if (norm1 === 0 || norm2 === 0) return 0;\n  return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));\n};\n\n/**\r\n * Calculate TF-IDF similarity score between prompt and text\r\n */\nexport const calculateTFIDFScore = (prompt, posts) => {\n  const promptWords = preprocessText(prompt);\n  const postTexts = posts.map(post => preprocessText(`${post.title} ${post.snippet}`));\n\n  // Create documents array (prompt + all posts)\n  const documents = [promptWords, ...postTexts];\n\n  // Calculate TF-IDF vectors\n  const tfidfVectors = calculateTFIDF(documents);\n\n  // Calculate similarity between prompt (index 0) and each post\n  const promptVector = tfidfVectors[0];\n  const scores = [];\n  for (let i = 1; i < tfidfVectors.length; i++) {\n    const similarity = cosineSimilarity(promptVector, tfidfVectors[i]);\n    scores.push(similarity);\n  }\n  return scores;\n};\n\n/**\r\n * Rank posts based on combined keyword and TF-IDF scores\r\n */\nexport const rankPosts = (prompt, posts, keywordWeight = 0.4, tfidfWeight = 0.6) => {\n  if (!posts || posts.length === 0) return [];\n\n  // Calculate TF-IDF scores for all posts\n  const tfidfScores = calculateTFIDFScore(prompt, posts);\n\n  // Calculate combined scores\n  const rankedPosts = posts.map((post, index) => {\n    const keywordScore = calculateKeywordScore(prompt, `${post.title} ${post.snippet}`);\n    const tfidfScore = tfidfScores[index] || 0;\n    const finalScore = keywordScore * keywordWeight + tfidfScore * tfidfWeight;\n    return {\n      ...post,\n      keywordScore,\n      tfidfScore,\n      finalScore\n    };\n  });\n\n  // Sort by final score (descending)\n  return rankedPosts.sort((a, b) => b.finalScore - a.finalScore);\n};","map":{"version":3,"names":["STOPWORDS","Set","preprocessText","text","toLowerCase","replace","split","filter","word","length","has","calculateKeywordScore","prompt","promptWords","textWords","matches","includes","calculateTF","words","tf","totalWords","forEach","Object","keys","calculateIDF","documents","idf","totalDocs","allWords","doc","add","docsWithWord","Math","log","calculateTFIDF","tfidfVectors","tfidf","push","cosineSimilarity","vec1","vec2","words1","words2","dotProduct","norm1","norm2","val1","val2","sqrt","calculateTFIDFScore","posts","postTexts","map","post","title","snippet","promptVector","scores","i","similarity","rankPosts","keywordWeight","tfidfWeight","tfidfScores","rankedPosts","index","keywordScore","tfidfScore","finalScore","sort","a","b"],"sources":["C:/Users/harsh/OneDrive/Github/RS project/src/utils/ranking.js"],"sourcesContent":["// Common English stopwords\r\nconst STOPWORDS = new Set([\r\n  'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'has', 'he',\r\n  'in', 'is', 'it', 'its', 'of', 'on', 'that', 'the', 'to', 'was', 'will', 'with',\r\n  'but', 'or', 'not', 'this', 'they', 'have', 'had', 'what', 'said', 'each',\r\n  'which', 'do', 'how', 'their', 'if', 'up', 'out', 'many', 'then', 'them',\r\n  'can', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'will'\r\n]);\r\n\r\n/**\r\n * Preprocess text: lowercase, remove punctuation, filter stopwords\r\n */\r\nexport const preprocessText = (text) => {\r\n  if (!text) return [];\r\n  \r\n  return text\r\n    .toLowerCase()\r\n    .replace(/[^\\w\\s]/g, ' ') // Remove punctuation\r\n    .split(/\\s+/)\r\n    .filter(word => word.length > 2 && !STOPWORDS.has(word));\r\n};\r\n\r\n/**\r\n * Calculate keyword matching score\r\n */\r\nexport const calculateKeywordScore = (prompt, text) => {\r\n  const promptWords = preprocessText(prompt);\r\n  const textWords = preprocessText(text);\r\n  \r\n  if (promptWords.length === 0) return 0;\r\n  \r\n  const matches = promptWords.filter(word => textWords.includes(word));\r\n  return matches.length / promptWords.length; // Normalized score\r\n};\r\n\r\n/**\r\n * Calculate Term Frequency (TF)\r\n */\r\nconst calculateTF = (words) => {\r\n  const tf = {};\r\n  const totalWords = words.length;\r\n  \r\n  words.forEach(word => {\r\n    tf[word] = (tf[word] || 0) + 1;\r\n  });\r\n  \r\n  // Normalize by total words\r\n  Object.keys(tf).forEach(word => {\r\n    tf[word] = tf[word] / totalWords;\r\n  });\r\n  \r\n  return tf;\r\n};\r\n\r\n/**\r\n * Calculate Inverse Document Frequency (IDF)\r\n */\r\nconst calculateIDF = (documents) => {\r\n  const idf = {};\r\n  const totalDocs = documents.length;\r\n  \r\n  // Get all unique words\r\n  const allWords = new Set();\r\n  documents.forEach(doc => {\r\n    doc.forEach(word => allWords.add(word));\r\n  });\r\n  \r\n  // Calculate IDF for each word\r\n  allWords.forEach(word => {\r\n    const docsWithWord = documents.filter(doc => doc.includes(word)).length;\r\n    idf[word] = Math.log(totalDocs / (docsWithWord + 1)); // +1 to avoid division by zero\r\n  });\r\n  \r\n  return idf;\r\n};\r\n\r\n/**\r\n * Calculate TF-IDF vectors\r\n */\r\nconst calculateTFIDF = (documents) => {\r\n  const tfidfVectors = [];\r\n  const idf = calculateIDF(documents);\r\n  \r\n  documents.forEach(doc => {\r\n    const tf = calculateTF(doc);\r\n    const tfidf = {};\r\n    \r\n    Object.keys(tf).forEach(word => {\r\n      tfidf[word] = tf[word] * idf[word];\r\n    });\r\n    \r\n    tfidfVectors.push(tfidf);\r\n  });\r\n  \r\n  return tfidfVectors;\r\n};\r\n\r\n/**\r\n * Calculate cosine similarity between two TF-IDF vectors\r\n */\r\nconst cosineSimilarity = (vec1, vec2) => {\r\n  const words1 = Object.keys(vec1);\r\n  const words2 = Object.keys(vec2);\r\n  const allWords = new Set([...words1, ...words2]);\r\n  \r\n  let dotProduct = 0;\r\n  let norm1 = 0;\r\n  let norm2 = 0;\r\n  \r\n  allWords.forEach(word => {\r\n    const val1 = vec1[word] || 0;\r\n    const val2 = vec2[word] || 0;\r\n    \r\n    dotProduct += val1 * val2;\r\n    norm1 += val1 * val1;\r\n    norm2 += val2 * val2;\r\n  });\r\n  \r\n  if (norm1 === 0 || norm2 === 0) return 0;\r\n  \r\n  return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));\r\n};\r\n\r\n/**\r\n * Calculate TF-IDF similarity score between prompt and text\r\n */\r\nexport const calculateTFIDFScore = (prompt, posts) => {\r\n  const promptWords = preprocessText(prompt);\r\n  const postTexts = posts.map(post => \r\n    preprocessText(`${post.title} ${post.snippet}`)\r\n  );\r\n  \r\n  // Create documents array (prompt + all posts)\r\n  const documents = [promptWords, ...postTexts];\r\n  \r\n  // Calculate TF-IDF vectors\r\n  const tfidfVectors = calculateTFIDF(documents);\r\n  \r\n  // Calculate similarity between prompt (index 0) and each post\r\n  const promptVector = tfidfVectors[0];\r\n  const scores = [];\r\n  \r\n  for (let i = 1; i < tfidfVectors.length; i++) {\r\n    const similarity = cosineSimilarity(promptVector, tfidfVectors[i]);\r\n    scores.push(similarity);\r\n  }\r\n  \r\n  return scores;\r\n};\r\n\r\n/**\r\n * Rank posts based on combined keyword and TF-IDF scores\r\n */\r\nexport const rankPosts = (prompt, posts, keywordWeight = 0.4, tfidfWeight = 0.6) => {\r\n  if (!posts || posts.length === 0) return [];\r\n  \r\n  // Calculate TF-IDF scores for all posts\r\n  const tfidfScores = calculateTFIDFScore(prompt, posts);\r\n  \r\n  // Calculate combined scores\r\n  const rankedPosts = posts.map((post, index) => {\r\n    const keywordScore = calculateKeywordScore(prompt, `${post.title} ${post.snippet}`);\r\n    const tfidfScore = tfidfScores[index] || 0;\r\n    \r\n    const finalScore = (keywordScore * keywordWeight) + (tfidfScore * tfidfWeight);\r\n    \r\n    return {\r\n      ...post,\r\n      keywordScore,\r\n      tfidfScore,\r\n      finalScore\r\n    };\r\n  });\r\n  \r\n  // Sort by final score (descending)\r\n  return rankedPosts.sort((a, b) => b.finalScore - a.finalScore);\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}