{"ast":null,"code":"// Common English stopwords\nconst STOPWORDS = new Set(['a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on', 'that', 'the', 'to', 'was', 'will', 'with', 'but', 'or', 'not', 'this', 'they', 'have', 'had', 'what', 'said', 'each', 'which', 'do', 'how', 'their', 'if', 'up', 'out', 'many', 'then', 'them', 'can', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'will']);\n\n/**\n * Preprocess text: lowercase, remove punctuation, filter stopwords\n */\nexport const preprocessText = text => {\n  if (!text) return [];\n  return text.toLowerCase().replace(/[^\\w\\s]/g, ' ') // Remove punctuation\n  .split(/\\s+/).filter(word => word.length > 2 && !STOPWORDS.has(word));\n};\n\n/**\n * Calculate keyword matching score with details\n */\nexport const calculateKeywordScore = (prompt, text, returnDetails = false) => {\n  const promptWords = preprocessText(prompt);\n  const textWords = preprocessText(text);\n  if (promptWords.length === 0) return returnDetails ? {\n    score: 0,\n    details: {}\n  } : 0;\n  const matches = promptWords.filter(word => textWords.includes(word));\n  const score = matches.length / promptWords.length;\n  if (returnDetails) {\n    return {\n      score,\n      details: {\n        queryWords: promptWords,\n        textWords: textWords,\n        matchedWords: matches,\n        totalQueryWords: promptWords.length,\n        matchedCount: matches.length\n      }\n    };\n  }\n  return score;\n};\n\n/**\n * Calculate Term Frequency (TF)\n */\nconst calculateTF = words => {\n  const tf = {};\n  const totalWords = words.length;\n  words.forEach(word => {\n    tf[word] = (tf[word] || 0) + 1;\n  });\n\n  // Normalize by total words\n  Object.keys(tf).forEach(word => {\n    tf[word] = tf[word] / totalWords;\n  });\n  return tf;\n};\n\n/**\n * Calculate Inverse Document Frequency (IDF)\n */\nconst calculateIDF = documents => {\n  const idf = {};\n  const totalDocs = documents.length;\n\n  // Get all unique words\n  const allWords = new Set();\n  documents.forEach(doc => {\n    doc.forEach(word => allWords.add(word));\n  });\n\n  // Calculate IDF for each word\n  allWords.forEach(word => {\n    const docsWithWord = documents.filter(doc => doc.includes(word)).length;\n    idf[word] = Math.log(totalDocs / (docsWithWord + 1)); // +1 to avoid division by zero\n  });\n  return idf;\n};\n\n/**\n * Calculate TF-IDF vectors\n */\nconst calculateTFIDF = documents => {\n  const tfidfVectors = [];\n  const idf = calculateIDF(documents);\n  documents.forEach(doc => {\n    const tf = calculateTF(doc);\n    const tfidf = {};\n    Object.keys(tf).forEach(word => {\n      tfidf[word] = tf[word] * idf[word];\n    });\n    tfidfVectors.push(tfidf);\n  });\n  return tfidfVectors;\n};\n\n/**\n * Calculate cosine similarity between two TF-IDF vectors with details\n */\nconst cosineSimilarity = (vec1, vec2, returnDetails = false) => {\n  const words1 = Object.keys(vec1);\n  const words2 = Object.keys(vec2);\n  const allWords = new Set([...words1, ...words2]);\n  let dotProduct = 0;\n  let norm1 = 0;\n  let norm2 = 0;\n  allWords.forEach(word => {\n    const val1 = vec1[word] || 0;\n    const val2 = vec2[word] || 0;\n    dotProduct += val1 * val2;\n    norm1 += val1 * val1;\n    norm2 += val2 * val2;\n  });\n  if (norm1 === 0 || norm2 === 0) {\n    return returnDetails ? {\n      similarity: 0,\n      details: {\n        dotProduct: 0,\n        norm1: 0,\n        norm2: 0\n      }\n    } : 0;\n  }\n  const similarity = dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));\n  if (returnDetails) {\n    return {\n      similarity,\n      details: {\n        dotProduct,\n        norm1: Math.sqrt(norm1),\n        norm2: Math.sqrt(norm2)\n      }\n    };\n  }\n  return similarity;\n};\n\n/**\n * Calculate TF-IDF similarity score between prompt and text\n */\nexport const calculateTFIDFScore = (prompt, posts) => {\n  const promptWords = preprocessText(prompt);\n  const postTexts = posts.map(post => preprocessText(`${post.title} ${post.snippet}`));\n\n  // Create documents array (prompt + all posts)\n  const documents = [promptWords, ...postTexts];\n\n  // Calculate TF-IDF vectors\n  const tfidfVectors = calculateTFIDF(documents);\n\n  // Calculate similarity between prompt (index 0) and each post\n  const promptVector = tfidfVectors[0];\n  const scores = [];\n  for (let i = 1; i < tfidfVectors.length; i++) {\n    const similarity = cosineSimilarity(promptVector, tfidfVectors[i]);\n    scores.push(similarity);\n  }\n  return scores;\n};\n\n/**\n * Rank posts based on combined keyword and TF-IDF scores with detailed calculations\n */\nexport const rankPosts = (prompt, posts, keywordWeight = 0.4, tfidfWeight = 0.6) => {\n  if (!posts || posts.length === 0) return [];\n\n  // Preprocess data for detailed calculations\n  const promptWords = preprocessText(prompt);\n  const postTexts = posts.map(post => preprocessText(`${post.title} ${post.snippet}`));\n\n  // Create documents array (prompt + all posts)\n  const documents = [promptWords, ...postTexts];\n\n  // Calculate TF-IDF vectors and IDF\n  const idf = calculateIDF(documents);\n  const tfidfVectors = calculateTFIDF(documents);\n  const promptVector = tfidfVectors[0];\n\n  // Calculate TF-IDF scores for all posts\n  const tfidfScores = calculateTFIDFScore(prompt, posts);\n\n  // Calculate combined scores with detailed information\n  const rankedPosts = posts.map((post, index) => {\n    const postText = `${post.title} ${post.snippet}`;\n    const keywordResult = calculateKeywordScore(prompt, postText, true);\n    const tfidfScore = tfidfScores[index] || 0;\n\n    // Get detailed TF-IDF calculation\n    const postVector = tfidfVectors[index + 1];\n    const similarityResult = cosineSimilarity(promptVector, postVector, true);\n\n    // Get top TF words for this post with detailed calculation data\n    const postWords = preprocessText(postText);\n    const tf = calculateTF(postWords);\n    const wordCounts = {};\n    postWords.forEach(word => {\n      wordCounts[word] = (wordCounts[word] || 0) + 1;\n    });\n    const topTFWords = Object.entries(tf).sort(([, a], [, b]) => b - a).slice(0, 4).map(([word, tfValue]) => ({\n      word,\n      tf: tfValue,\n      count: wordCounts[word] || 0,\n      totalWords: postWords.length\n    }));\n\n    // Get top IDF words from query with detailed calculation data\n    const totalDocs = documents.length;\n    const topIDFWords = promptWords.map(word => {\n      const docsWithWord = documents.filter(doc => doc.includes(word)).length;\n      return {\n        word,\n        idf: idf[word] || 0,\n        totalDocs,\n        docsWithWord\n      };\n    }).sort((a, b) => b.idf - a.idf).slice(0, 4);\n    const finalScore = keywordResult.score * keywordWeight + tfidfScore * tfidfWeight;\n    return {\n      ...post,\n      keywordScore: keywordResult.score,\n      tfidfScore,\n      finalScore,\n      calculationDetails: {\n        queryWords: keywordResult.details.queryWords,\n        matchedWords: keywordResult.details.matchedWords,\n        topTFWords,\n        topIDFWords,\n        dotProduct: similarityResult.details.dotProduct,\n        queryNorm: similarityResult.details.norm1,\n        postNorm: similarityResult.details.norm2\n      }\n    };\n  });\n\n  // Sort by final score (descending)\n  return rankedPosts.sort((a, b) => b.finalScore - a.finalScore);\n};","map":{"version":3,"names":["STOPWORDS","Set","preprocessText","text","toLowerCase","replace","split","filter","word","length","has","calculateKeywordScore","prompt","returnDetails","promptWords","textWords","score","details","matches","includes","queryWords","matchedWords","totalQueryWords","matchedCount","calculateTF","words","tf","totalWords","forEach","Object","keys","calculateIDF","documents","idf","totalDocs","allWords","doc","add","docsWithWord","Math","log","calculateTFIDF","tfidfVectors","tfidf","push","cosineSimilarity","vec1","vec2","words1","words2","dotProduct","norm1","norm2","val1","val2","similarity","sqrt","calculateTFIDFScore","posts","postTexts","map","post","title","snippet","promptVector","scores","i","rankPosts","keywordWeight","tfidfWeight","tfidfScores","rankedPosts","index","postText","keywordResult","tfidfScore","postVector","similarityResult","postWords","wordCounts","topTFWords","entries","sort","a","b","slice","tfValue","count","topIDFWords","finalScore","keywordScore","calculationDetails","queryNorm","postNorm"],"sources":["C:/Users/harsh/OneDrive/Github/RS project/src/utils/ranking.js"],"sourcesContent":["// Common English stopwords\nconst STOPWORDS = new Set([\n  'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'has', 'he',\n  'in', 'is', 'it', 'its', 'of', 'on', 'that', 'the', 'to', 'was', 'will', 'with',\n  'but', 'or', 'not', 'this', 'they', 'have', 'had', 'what', 'said', 'each',\n  'which', 'do', 'how', 'their', 'if', 'up', 'out', 'many', 'then', 'them',\n  'can', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'will'\n]);\n\n/**\n * Preprocess text: lowercase, remove punctuation, filter stopwords\n */\nexport const preprocessText = (text) => {\n  if (!text) return [];\n  \n  return text\n    .toLowerCase()\n    .replace(/[^\\w\\s]/g, ' ') // Remove punctuation\n    .split(/\\s+/)\n    .filter(word => word.length > 2 && !STOPWORDS.has(word));\n};\n\n/**\n * Calculate keyword matching score with details\n */\nexport const calculateKeywordScore = (prompt, text, returnDetails = false) => {\n  const promptWords = preprocessText(prompt);\n  const textWords = preprocessText(text);\n  \n  if (promptWords.length === 0) return returnDetails ? { score: 0, details: {} } : 0;\n  \n  const matches = promptWords.filter(word => textWords.includes(word));\n  const score = matches.length / promptWords.length;\n  \n  if (returnDetails) {\n    return {\n      score,\n      details: {\n        queryWords: promptWords,\n        textWords: textWords,\n        matchedWords: matches,\n        totalQueryWords: promptWords.length,\n        matchedCount: matches.length\n      }\n    };\n  }\n  \n  return score;\n};\n\n/**\n * Calculate Term Frequency (TF)\n */\nconst calculateTF = (words) => {\n  const tf = {};\n  const totalWords = words.length;\n  \n  words.forEach(word => {\n    tf[word] = (tf[word] || 0) + 1;\n  });\n  \n  // Normalize by total words\n  Object.keys(tf).forEach(word => {\n    tf[word] = tf[word] / totalWords;\n  });\n  \n  return tf;\n};\n\n/**\n * Calculate Inverse Document Frequency (IDF)\n */\nconst calculateIDF = (documents) => {\n  const idf = {};\n  const totalDocs = documents.length;\n  \n  // Get all unique words\n  const allWords = new Set();\n  documents.forEach(doc => {\n    doc.forEach(word => allWords.add(word));\n  });\n  \n  // Calculate IDF for each word\n  allWords.forEach(word => {\n    const docsWithWord = documents.filter(doc => doc.includes(word)).length;\n    idf[word] = Math.log(totalDocs / (docsWithWord + 1)); // +1 to avoid division by zero\n  });\n  \n  return idf;\n};\n\n/**\n * Calculate TF-IDF vectors\n */\nconst calculateTFIDF = (documents) => {\n  const tfidfVectors = [];\n  const idf = calculateIDF(documents);\n  \n  documents.forEach(doc => {\n    const tf = calculateTF(doc);\n    const tfidf = {};\n    \n    Object.keys(tf).forEach(word => {\n      tfidf[word] = tf[word] * idf[word];\n    });\n    \n    tfidfVectors.push(tfidf);\n  });\n  \n  return tfidfVectors;\n};\n\n/**\n * Calculate cosine similarity between two TF-IDF vectors with details\n */\nconst cosineSimilarity = (vec1, vec2, returnDetails = false) => {\n  const words1 = Object.keys(vec1);\n  const words2 = Object.keys(vec2);\n  const allWords = new Set([...words1, ...words2]);\n  \n  let dotProduct = 0;\n  let norm1 = 0;\n  let norm2 = 0;\n  \n  allWords.forEach(word => {\n    const val1 = vec1[word] || 0;\n    const val2 = vec2[word] || 0;\n    \n    dotProduct += val1 * val2;\n    norm1 += val1 * val1;\n    norm2 += val2 * val2;\n  });\n  \n  if (norm1 === 0 || norm2 === 0) {\n    return returnDetails ? { similarity: 0, details: { dotProduct: 0, norm1: 0, norm2: 0 } } : 0;\n  }\n  \n  const similarity = dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));\n  \n  if (returnDetails) {\n    return {\n      similarity,\n      details: {\n        dotProduct,\n        norm1: Math.sqrt(norm1),\n        norm2: Math.sqrt(norm2)\n      }\n    };\n  }\n  \n  return similarity;\n};\n\n/**\n * Calculate TF-IDF similarity score between prompt and text\n */\nexport const calculateTFIDFScore = (prompt, posts) => {\n  const promptWords = preprocessText(prompt);\n  const postTexts = posts.map(post => \n    preprocessText(`${post.title} ${post.snippet}`)\n  );\n  \n  // Create documents array (prompt + all posts)\n  const documents = [promptWords, ...postTexts];\n  \n  // Calculate TF-IDF vectors\n  const tfidfVectors = calculateTFIDF(documents);\n  \n  // Calculate similarity between prompt (index 0) and each post\n  const promptVector = tfidfVectors[0];\n  const scores = [];\n  \n  for (let i = 1; i < tfidfVectors.length; i++) {\n    const similarity = cosineSimilarity(promptVector, tfidfVectors[i]);\n    scores.push(similarity);\n  }\n  \n  return scores;\n};\n\n/**\n * Rank posts based on combined keyword and TF-IDF scores with detailed calculations\n */\nexport const rankPosts = (prompt, posts, keywordWeight = 0.4, tfidfWeight = 0.6) => {\n  if (!posts || posts.length === 0) return [];\n  \n  // Preprocess data for detailed calculations\n  const promptWords = preprocessText(prompt);\n  const postTexts = posts.map(post => \n    preprocessText(`${post.title} ${post.snippet}`)\n  );\n  \n  // Create documents array (prompt + all posts)\n  const documents = [promptWords, ...postTexts];\n  \n  // Calculate TF-IDF vectors and IDF\n  const idf = calculateIDF(documents);\n  const tfidfVectors = calculateTFIDF(documents);\n  const promptVector = tfidfVectors[0];\n  \n  // Calculate TF-IDF scores for all posts\n  const tfidfScores = calculateTFIDFScore(prompt, posts);\n  \n  // Calculate combined scores with detailed information\n  const rankedPosts = posts.map((post, index) => {\n    const postText = `${post.title} ${post.snippet}`;\n    const keywordResult = calculateKeywordScore(prompt, postText, true);\n    const tfidfScore = tfidfScores[index] || 0;\n    \n    // Get detailed TF-IDF calculation\n    const postVector = tfidfVectors[index + 1];\n    const similarityResult = cosineSimilarity(promptVector, postVector, true);\n    \n    // Get top TF words for this post with detailed calculation data\n    const postWords = preprocessText(postText);\n    const tf = calculateTF(postWords);\n    const wordCounts = {};\n    postWords.forEach(word => {\n      wordCounts[word] = (wordCounts[word] || 0) + 1;\n    });\n    \n    const topTFWords = Object.entries(tf)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 4)\n      .map(([word, tfValue]) => ({ \n        word, \n        tf: tfValue,\n        count: wordCounts[word] || 0,\n        totalWords: postWords.length\n      }));\n    \n    // Get top IDF words from query with detailed calculation data\n    const totalDocs = documents.length;\n    const topIDFWords = promptWords\n      .map(word => {\n        const docsWithWord = documents.filter(doc => doc.includes(word)).length;\n        return { \n          word, \n          idf: idf[word] || 0,\n          totalDocs,\n          docsWithWord\n        };\n      })\n      .sort((a, b) => b.idf - a.idf)\n      .slice(0, 4);\n    \n    const finalScore = (keywordResult.score * keywordWeight) + (tfidfScore * tfidfWeight);\n    \n    return {\n      ...post,\n      keywordScore: keywordResult.score,\n      tfidfScore,\n      finalScore,\n      calculationDetails: {\n        queryWords: keywordResult.details.queryWords,\n        matchedWords: keywordResult.details.matchedWords,\n        topTFWords,\n        topIDFWords,\n        dotProduct: similarityResult.details.dotProduct,\n        queryNorm: similarityResult.details.norm1,\n        postNorm: similarityResult.details.norm2\n      }\n    };\n  });\n  \n  // Sort by final score (descending)\n  return rankedPosts.sort((a, b) => b.finalScore - a.finalScore);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}